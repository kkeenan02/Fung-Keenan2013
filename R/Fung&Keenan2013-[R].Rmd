<center>
Fung & Keenan 2013: Description of R programs used to calculate  confidence intervals
========================================================

Tak Fung^1,2 and Kevin Keenan^3
----------------------------------------------------

<h6>
https://github.com/kkeenan02/Fung-Keenan2013.git
<sup>1</sup> National University of Singapore, Department of Biological Sciences, 14 Science Drive 4, Singapore 117543

<sup>2</sup> Queen’s University Belfast, School of Biological Sciences, Belfast BT9 7BL, UK

<sup>3</sup> Queen’s University Belfast, Institute for Global Food Security, School of Biological Sciences, Belfast BT9 7BL, UK

</center>
</h6>

### Introduction
This document describes the functionality of the R code converted from the _Mathematica_ code used in Fung & Keenan 2013. The code was written and tested using _Mathematica_ v5.0[1] and subsequently converted and tested in `R`. This document describes four seperate programs named, `pmfSamplingDistYiN`, `AcceptanceRegion`, `CIforpiCasePiiUnknown` and `CIforpiCasePiiknown`. This document has is also available for _Mathematica_ users at: https://github.com/kkeenan02/Fung-Keenan2013 in the Mathematica folder.

#### `pmfSamplingDistYiN`
This program returns $P(Y_{i,N} = y_{i,N})$ as specified by equation (9) in the main text, give $M$, $N$, $p_{i}$, $P_{ii}$ and $y_{i,n}$. Here, $Y_{i,N}$ is the random variable specifying the number of copies of allele $A_{i}$ in a sample of size $N$ taken from a finite diploid population of size $M$, with the frequency of allele $A_{i}$ in the population being $p_{i}$ and the frequency of homozygotes of allele $A_{i}$ in the population being $P_{ii}$.

```{r, echo=FALSE}
opts_chunk$set(comment = "",
               tidy = FALSE)
options(digits = 6)
```

##### `pmfSamplingDistYiN` source code (`R`)
```{r}
pmfSamplingDistYiN <- function(M, NN, p_i, P_ii, yiN){
  MaxFunc <- max((yiN/2) - (M*p_i) + (M*P_ii), yiN - NN, 0)
  MinFunc <- min(M*P_ii, yiN/2, M-NN+yiN-(2*M*p_i)+(M*P_ii))
  LowerBound <- ceiling(MaxFunc)
  UpperBound <- floor(MinFunc)
  
  # Calculate P(YiN = yiN) according to eqn 9
  Numerator1 <- 0
  
  for(i in LowerBound:UpperBound){
    Summand <- choose(M*P_ii, i)*choose(2*M*(p_i-P_ii), yiN-(2*i))*
      choose(M+(M*P_ii)-(2*M*p_i), NN+i-yiN)
    Numerator1 <- Numerator1 + Summand
  }
  
  probOut <- Numerator1/choose(M, NN)
  return(probOut)
}
```

##### `pmfSamplingDistYiN` example
```{r}
# test timing
system.time(res <- pmfSamplingDistYiN(1000, 10, 0.1, 0.04, 1))
# print results
print(res)
```
